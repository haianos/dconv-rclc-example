/*
 * Simple example to integrate dconv runtime in 
 * a ROS component (ROS2::rclc, subscriber example)
 * 
 * Author: Enea Scioni, <enea.scioni@kuleuven.be>
 * 
 */

/* 
 * In this example, dconv runtime is used to convert
 * an incoming message (geometry_msgs/Point, ddr)
 * to an internal representation (double[3], ddr),
 * by means of dproto models.
 * This file is the source of the subscriber.
 * In the example, the host code (*this*) is responsible
 * to allocate properly all the data.
 * ROS provides a *pointer* to the topic message, which
 * may be bufferised.
 * In the same way the internal data is threated: 
 * handled in *this* code.
 */

// Just regular C-stuff
#include <stdio.h>

//ROS2 rclc stuff
#include <rclc/rclc.h>

//The ROS2 message we want to receive
#include <geometry_msgs/msg/point.h>

//Lua5.2 -- needed for the runtime
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/*       Generic Lua utilities (handling Lua state)      */
/* TODO: provide those as source or library to include   */

/* initialise Lua state */
const lua_State* init_lua() {
   lua_State* L = luaL_newstate();
   luaL_openlibs(L);
   return L;
}

/* destroy Lua state    */
void destroy_lua(lua_State* L) {
  lua_close(L);
}

/* Execute a Lua script (external chunk)  */
int execute_file(lua_State* L, const char* name) {
    int error = luaL_loadfile(L,name);
    if (error != 0) {
        fprintf(stderr, "executeFile : error during loading/compiling :\n  %s\n ",lua_tostring(L, -1)); 
        lua_pop(L, 1);  /* pop error message from the stack */
        return 1;
    }
    error = lua_pcall(L,0,0,0);
    if (error != 0) {
      fprintf(stderr,"executeFile : error during execution :\n  %s\n ",lua_tostring(L, -1)); 
        lua_pop(L, 1);  /* pop error message from the stack */
        return 2;
    }
    return 0;
}

/*  Executing a string as Lua chunk */
int execute_string(lua_State* L, const char* str) {
   int error = luaL_loadbuffer(L,str,strlen(str),"execute_string");
    if (error != 0) {
        fprintf(stderr,"executeString : error during loading/compiling :\n ",lua_tostring(L, -1));
        lua_pop(L, 1);  /* pop error message from the stack */
        return 1;
    }
    error = lua_pcall(L,0,0,0);
    if (error != 0) {
        fprintf(stderr,"executeString : error during execution :\n ",lua_tostring(L, -1));
        lua_pop(L, 1);  /* pop error message from the stack */
        return 2;
    }
    return 0;
}

/* This just push in th Lua state the .dproto file */
int push_datamodel(lua_State* L, const char* name){
  lua_pushstring(L,name);
  lua_setglobal(L,"dprotofile");
  return 0;
}


/*  ------    Some states     ------ */
/* THE Lua state -- singleton in this example */
lua_State* L;
/* pointer to our internal data               */
double* internal_userdata;



//should be autogenerated
int push_geometry_msgs__msg__Point(geometry_msgs__msg__Point* msg) {
  lua_getglobal(L,"ffi");
  lua_getfield(L,1,"new");
  lua_pushstring(L,"geometry_msgs__msg__Point*"); //TODO concatenate name type with pointer symbol
  lua_pushlightuserdata(L,(void*)(msg));
  lua_call(L,2,1);
  lua_setglobal(L,"msg");
//   printf("size: %d\n",lua_gettop(L));
  
  lua_pop(L,1);
  return 0;
}

int register_dblx(const char* dproto,const char* id,void* p) {
  lua_getglobal(L,"register_dblx");
  lua_pushstring(L,dproto);
  lua_pushstring(L,id);
  if (p == NULL)
    lua_call(L,2,0);
  else {
    lua_pushlightuserdata(L,p);
    lua_call(L,3,0);
  }
  return 0;
}

#define CDATA_OVERHEAD 0x20

void get_value(const char* id) {
  lua_getglobal(L,"get_dblx");
  lua_pushstring(L,id);
  lua_call(L,1,1);
  void* p = (void*)lua_touserdata(L,1);
  double* d = (double*)(p+CDATA_OVERHEAD);
  printf("%f %f %f\n",d[0],d[1],d[2]);
  printf("size: %d\n",lua_gettop(L));
  lua_pop(L,1);
  return 0;
}

double* get_internal_userdata(const char* id) {
  lua_getglobal(L,"get_dblx");
  lua_pushstring(L,id);
  lua_call(L,1,1);
  void* p = (void*)lua_touserdata(L,1);
  return (double*)(p+CDATA_OVERHEAD);
}

void set_reference(lua_State* L,const char* id,void* ref) {
  lua_getglobal(L,"change_ref");
  lua_pushstring(L,id);
  lua_pushlightuserdata(L,ref);
  lua_call(L,2,0);
}

/* ROS CALLBACK -- where the host code resides */
/* FROM HERE ON, IT'S USER-CODE. The previous will be shipped as external source/library */
void callback(const void* msg) {
  set_reference(L,"incoming",msg);                      //this sets the reference to the dblx 'incoming', previously unbounded
  execute_string(L,"convert('incoming','internal')");  //this inkoves the conversion
  printf("USER: %f %f %f\n",internal_userdata[0],internal_userdata[1],internal_userdata[2]); //data converted with indicated ddr (double[3]), ready to be used in the user-code (component's internals)
}

void helper() {
  printf("Simple subscriber example with dconv integrated in host code\n");
  printf("run as: <arg1> <arg2>, where\n");
  printf("  - arg1: .dproto file\n");
  printf("  - arg2: init script (.lua)\n");
}

int main(int argc, char** argv) {
  printf("Starting up...\n");
  
  if (argc != 3){
    helper();
    return -1;
  }
  /* init ROS  */
  rclc_init(0, NULL);
  rclc_node_t* node = rclc_create_node("subnode", "/ns");
  
  /* init Lua  */
  L = init_lua();
  
  push_datamodel(L,argv[1]);
  execute_file(L,argv[2]);
  
  /* Registering DBLX */
  //                   DPROTO MODEL       DBLX ID   POINTER TO DATA; provided by the callback
  register_dblx("semantic_ros_position","incoming",NULL);  //NOTE: avoid using `incoming` until data is registered
  double mydata[3];
  internal_userdata = &mydata;//(double*)malloc(sizeof(double)*3); //double[3]
  // we fully bound 'internal_userdata' in this example, no need of extra steps per message arrived.
  register_dblx("semantic_plain_position","internal",(void*)internal_userdata);
  printf("STARTED\n");
  
  rclc_subscription_t * sub =
      rclc_create_subscription(node,
        RCLC_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Point),
        "topic", callback, 0, false);
    

  rclc_spin_node(node);
  
  printf("Bye!!\n");
  
  /*     Cleaninig all up              */
  rclc_destroy_subscription(sub);
  destroy_lua(L);
  rclc_destroy_node(node);
  return 0;
}